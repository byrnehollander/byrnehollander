<!-- Renders to byrnehollander/_site/index.html -->
{% marginnote margin1 %} I've enabled [Hypothes.is annotation](https://hypothes.is/) on this page. Once you’re logged in, you can easily highlight and comment on specific text. If you don’t already have an account, you can use mine-- the username and password are both ‘bom_byrne’ {% endmarginnote %}
After applying to the Associate Product Manager position at Book of the Month, I’ve been considering how I would design a testing infrastructure for the website. I was surprised the site didn’t test along the way, but I understand the importance of balancing code quality and project schedule. Further, most of what I’ve seen is static and I don’t imagine much data is involved. Still, I decided to poke around and see what I could learn about the site and what problems better testing might solve. I begin this post with a discussion of testing and end with product ideas for Book of the Month.

{% marginnote margin1 %}
{% image https://i.imgur.com/P85mrQz.jpg 250 250 raw %}
{% endmarginnote %}

# Surveying the site

Armed with Chrome developer tools and the React DevTools extension, I took to the website. First, I simply tried all the features on the landing page to see if they worked as expected. One thing that caught my eye is how the page responds to a decreasing page width: the nav bar becomes a hamburger menu and the images scale (to a limit). Once the images reach a minimum size, the container overflows and the content can only be seen through side scrolling. Below is a short screencast to show this problem (along with another minor design inconsistency).

CAST

The easiest fix is to enable vertical tiling where appropriate. Below is quick mockup:

{% image https://i.imgur.com/P85mrQz.jpg 2560 1700 %}

Automated testing wouldn’t have found this bug because this issue is merely a design oversight. Thus, the problem would have to be anticipated in mobile mockups or by simply using the site on devices of various sizes (or simulating popular screen sizes).

After exploring the landing page, I tried making an account to learn about the other features. While I submitted the account creation form and my information was sent to the server, I didn't finish checking out, so my account was never created. If the intention is to only allow subscribers to have an account, I recommend moving the account password creation step after the checkout. Additionally, going back to the account creation page from the checkout page resulted in my username and password being lost. Still, it's possible that you intended for the account to be created, but an error prevented that from happening. I inspected the call to the server and there was no response (not even one confirming that the chosen email address is not yet registered). Still, I have evidence that my email *was* sent to the server. A bit after trying to create an account, I got an email reminding me to checkout. However, it was caught by my spam filter. {% sidenote side1 I wonder if sending an account registration email prior to this reminder would decrease the chances of the email going to spam. Regardless, I recommend changing the language of this reminder email so it has a better chance of reaching your audience. %}

After failing to make an account, I returned to the homepage to see what I could learn about the site’s structure. I saw that a logged in user has a slightly different view, and I was able to access some of this view by changing a prop. Below is a short screencast of this process. {% sidenote side2 The [react-keydown package](https://www.npmjs.com/package/react-keydown) can be easily implemented to improve navigation in modals. %}

CAST

At this point, I feel that I've come to a solid understanding of what the website does and what the testing infrastructure needs. It may be helpful to write a spec of important design decisions: how should the enrollment process be organized and why? Do we only want subscribers to have an account? When should we make calls to the server, what data should the calls have, and how should we respond? After writing this spec, it may prove useful to document every possible user interaction and the desired resulting behavior.

# Creating a testing infrastructure
If I were put in charge of testing, my process would be organized as follows:

1. I would first take stock of existing functionality and make sure everything works. I would also implement any minor improvements that could be completed within a few hours. For example, I’d make it a priority that the mobile view more intuitively renders overflow. Then, I’d add a few features to the modals: the modal would close if a user clicks or taps outside it, the navigation arrows would stay in the same location regardless of the modal height, and I would enable keyboard navigation.
2. Next, I would make sure [typechecking with PropTypes]( https://facebook.github.io/react/docs/typechecking-with-proptypes.html) is in use. PropTypes are an easy way to make sure the data you receive is valid, and should be a part of every React app.
3. Now, I would review the backend code. I would meet with others to identify under what circumstances the server needs to be called. I’d remove extraneous calls and decompose the remaining calls into modular functions. I would begin by writing unit tests{% sidenote side3 Not all unit tests were created equal—I would make sure my unit tests follow [these guidelines](https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d#.lx9b9iy5w) %}, which provide a realtime test feedback console for developers as they code. While writing these tests, it is important to track how much of the code you’ve tested. Code coverage is also great at keeping people accountable to run tests. Many tools like [Istanbul](https://github.com/dwyl/learn-istanbul) and [Codecov](https://codecov.io/) can be configured to add a badge to the repository’s readme, allowing even non-technical users to see how far along testing is. Additionally, it’s important to ensure uniform code style. You’re probably already using ESLint, which can be configured to [maintain testing style](https://github.com/airbnb/javascript#testing).
4. After, I would move to integration testing to validate that the user stories have been satisfied and that the functions work well together. {% marginnote margin2 %} There are many testing tools to choose from. For backend testing, Mocha is a popular testing environment and Chai is probably the most used assertion library. Personally, I think these overcomplicate things— I prefer Tape and Supertest. I highly recommend Eric Elliott’s [writing on the subject](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4#.5ng1arlsc) and [his recommend tools](https://github.com/ericelliott/essential-javascript-links#testing--lint--quality-checkers). Jarvis Badgley has written a more [code-forward argument](https://github.com/ChiperSoft/tape-vs-mocha) for Tape over Mocha. {% endmarginnote %} In general, I look to use tools that are easy to understand and fade into the background.
5. While I don’t know if existing front-end UI elements require testing, [Enzyme](https://medium.com/airbnb-engineering/enzyme-javascript-testing-utilities-for-react-a417e5e5090f#.tfqch85ic) is useful for testing UI and [plays nicely with Tape](http://airbnb.io/enzyme/docs/guides/tape-ava.html).
6. After integration testing comes end-to-end (e2e) testing, a technique used to test whether the flow of an application right from start to finish is behaving as expected. These tests identify system dependencies and ensure that data integrity is maintained between various system components and systems. Unfortunately, this means we need to [bring Selenium into the picture]( https://medium.com/@TuckerConnelly/good-practices-for-testing-react-apps-3a64154fa3b1#.ouzto5e53). While likely overkill for this project, we could at least set up the infrastructure for later development.
{% marginnote margin3 %} The right proportion of each test kind depends on the particular project, but I would begin by following Google’s 70-20-10 [testing pyramid ](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html). {% endmarginnote %}

IMAGE

Once the code is well tested, we need a development style that promotes the creation of new tests. I recommend the [Test Driven Development (TDD) framework]( https://medium.com/javascript-scene/tdd-the-rite-way-53c9b46f45e3#.40sc9h1x0) where requirements are turned into very specific test cases, then the software is improved to pass the new tests. This framework helps create code that is testable, maintains the single responsibility principle, and has deterministic behavior.

## Ensuring performance

At this point, everything should work! And we have a development framework to ensure that it keeps working. Still, we need to check that everything is working *well*. Thankfully, React has a nice suite of [performance tools] https://facebook.github.io/react/docs/perf.html) to make sure everything is running efficiently; [Chrome Timeline]( https://facebook.github.io/react/blog/2016/11/16/react-v15.4.0.html#profiling-components-with-chrome-timeline) can also help visualize which components exactly get mounted, updated, and unmounted, how much time they take relative to each other.

As far as the site’s general performance, I ran gtmetrix (screenshot below – need to find it). Right away, there is one easy change that can be made. Namely, you can use [chunking with WebPack]( https://medium.com/@addyosmani/progressive-web-apps-with-react-js-part-2-page-load-performance-33b932d97cf2#.xquhkap8f) to reduce the size of the concatenated .js file. It also prevents loading js embeds from loading on pages they aren’t used on (for example, ZenDesk chat).

Even if the website works and works quickly, the design can probably still be improved. I see that you have Hotjar enabled, so you can A/B test certain designs and see what works best. You may want to pay particular attention to the hamburger menu in the mobile version of the site. While I don’t know what the navigation needs of a logged in user are, the hamburger menu is [quite controversial](http://jamesarcher.me/hamburger-menu) and has been known to drive down user engagement.

# Creating a community

Lastly, I consider what would convince me to subscribe. My first thought was that I may not be the target audience: while I’m a voracious reader, I have a lengthy backlog of recommendations from friends, family, and professors. Still, I could see an improved product attracting some people. It could be a limited edition cover design, higher quality paper, or a sewn binding. While this model has been successful with design books and, recently, high quality, modern bibles like [Bibliophile](), books of the month aren’t necessarily heirlooms or books that will be frequently revisited. And, frankly, I don’t have space for more books and opt for digital versions when possible.

Thus, I think an active reading community would get me to subscribe, and the discussion section certainly hints at Book of the Month recognizing the importance of community. However, I think your discussion section requires some rethinking. First, I think a flat discussion would be easier to read and promote discussion that people can return to.{% sidenote side4 [This blog post]( https://blog.codinghorror.com/web-discussions-flat-by-design/) does good job describing why flat discussion is often the best solution.%} I also think you could use existing discussion tools rather than create your own. One such tool is [Discourse](https://www.discourse.org/). Discourse has been growing in popularity, and is inexpensive to implement. In addition to a sleek and effective interface, it’s easy to moderate and already has a cross-platform mobile app. Below is a short webcast showcasing several of the companies who use Discourse and what it looks like in action:

CAST

Further, Book of the Month subscribers could easily categorize their post by book and chapter. You could also incentivize judges and authors to participate in these discussions. You could additionally host something similar to Quora Sessions, and let users submit questions to ask judges or authors. Below is a quick screencast showing a Quora Session:

<figure>
          <div class='gfyitem' data-id='DaringUnfinishedGoshawk'></div>
        </figure>

And if you like this idea, [Discourse recently implemented something just like it]( https://github.com/discourse/discourse-voting)!

You could also build community by hosting events with authors and judges, or sponsoring meetups of readers. Would love to work with you and think I have a lot to add to the team.



<!-- <span><font size="-1">An early mockup I made of Notist's 'group view'<font size="-1"> -->

<!-- bundle install
bundle exec jekyll serve --baseurl '' -->
