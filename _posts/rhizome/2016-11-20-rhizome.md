<!-- Renders to byrnehollander/_site/index.html -->
{% marginnote margin1 %} I've enabled [Hypothes.is annotation](https://hypothes.is/) on this page. Once you’re logged in, you can easily highlight and comment on specific text. If you don’t already have an account, you can use mine-- the username and password are both ‘bom_byrne’ {% endmarginnote %}
After applying to the Associate Product Manager position at Book of the Month, I’ve been considering how I would design a testing infrastructure for the website. I was surprised the site didn’t test along the way, but I understand the importance of balancing code quality and project schedule. Further, most of what I’ve seen is static and I don’t imagine much data is involved. Still, I decided to poke around and see what I could learn about the site and what problems better testing might solve. I begin this post with a discussion of testing and end with product ideas for Book of the Month.

{% marginnote margin1 %}
{% image https://i.imgur.com/P85mrQz.jpg 250 250 raw %}
{% endmarginnote %}

# Surveying the site

Armed with Chrome developer tools and the React DevTools extension, I took to the website. First, I simply tried all the features on the landing page to see if they worked as expected. One thing that caught my eye is how the page responds to a decreasing page width: the nav bar becomes a hamburger menu and the images scale (to a limit). Once the images reach a minimum size, the container overflows and the content can only be seen through side scrolling. Below is a short screencast to show this problem (along with another minor design inconsistency).

CAST

The easiest fix is to enable vertical tiling where appropriate. Below is quick mockup:

{% image https://i.imgur.com/P85mrQz.jpg 2560 1700 %}

Automated testing wouldn’t have found this bug because this issue is merely a design oversight. Thus, the problem would have to be anticipated in mobile mockups or by simply using the site on devices of various sizes (or simulating popular screen sizes).

After exploring the landing page, I tried making an account to learn about the other features. While I submitted the account creation form and my information was sent to the server, I didn't finish checking out, so my account was never created. If the intention is to only allow subscribers to have an account, I recommend moving the account password creation step after the checkout. Additionally, going back to the account creation page from the checkout page resulted in my username and password being lost. Still, it's possible that you intended for the account to be created, but an error prevented that from happening. I inspected the call to the server and there was no response (not even one confirming that the chosen email address is not yet registered). Still, I have evidence that my email *was* sent to the server. A bit after trying to create an account, I got an email reminding me to checkout. However, it was caught by my spam filter. {% sidenote side1 I wonder if sending an account registration email prior to this reminder would decrease the chances of the email going to spam. Regardless, I recommend changing the language of this reminder email so it has a better chance of reaching your audience. %}

After failing to make an account, I returned to the homepage to see what I could learn about the site’s structure. I saw that a logged in user has a slightly different view, and I was able to access some of this view by changing a prop. Below is a short screencast of this process. {% sidenote side2 The [react-keydown package](https://www.npmjs.com/package/react-keydown) can be easily implemented to improve navigation in modals. %}

CAST

At this point, I feel that I've come to a solid understanding of what the website does and what the testing infrastructure needs. It may be helpful to write a spec of important design decisions: how should the enrollment process be organized and why? Do we only want subscribers to have an account? When should we make calls to the server, what data should the calls have, and how should we respond? After writing this spec, it may prove useful to document every possible user interaction and the desired resulting behavior.

# Creating a testing infrastructure
If I were put in charge of testing, my process would be organized as follows:

1. I would first take stock of existing functionality and make sure everything works. I would also implement any minor improvements that could be completed within a few hours. For example, I’d make it a priority that the mobile view more intuitively renders overflow. Then, I’d add a few features to the modals: the modal would close if a user clicks or taps outside it, the navigation arrows would stay in the same location regardless of the modal height, and I would enable keyboard navigation.
2. Next, I would make sure [typechecking with PropTypes]( https://facebook.github.io/react/docs/typechecking-with-proptypes.html) is in use. PropTypes are an easy way to make sure the data you receive is valid, and should be a part of every React app.
3. Now, I would review the backend code. I would meet with others to identify under what circumstances the server needs to be called. I’d remove extraneous calls and decompose the remaining calls into modular functions. I would begin by writing unit tests{% sidenote side3 Not all unit tests were created equal—I would make sure my unit tests follow [these guidelines](https://medium.com/javascript-scene/what-every-unit-test-needs-f6cd34d9836d#.lx9b9iy5w) %}, which provide a realtime test feedback console for developers as they code. While writing these tests, it is important to track how much of the code you’ve tested. Code coverage is also great at keeping people accountable to run tests. Many tools like [Istanbul](https://github.com/dwyl/learn-istanbul) and [Codecov](https://codecov.io/) can be configured to add a badge to the repository’s readme, allowing even non-technical users to see how far along testing is. Additionally, it’s important to ensure uniform code style. You’re probably already using ESLint, which can be configured to [maintain testing style](https://github.com/airbnb/javascript#testing).
4. After, I would move to integration testing to validate that the user stories have been satisfied and that the functions work well together. {% marginnote margin2 %} There are many testing tools to choose from. For backend testing, Mocha is a popular testing environment and Chai is probably the most used assertion library. Personally, I think these overcomplicate things— I prefer Tape and Supertest. I highly recommend Eric Elliott’s [writing on the subject](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4#.5ng1arlsc) and [his recommend tools](https://github.com/ericelliott/essential-javascript-links#testing--lint--quality-checkers). Jarvis Badgley has written a more [code-forward argument](https://github.com/ChiperSoft/tape-vs-mocha) for Tape over Mocha. {% endmarginnote %} In general, I look to use tools that are easy to understand and fade into the background.
5. While I don’t know if existing front-end UI elements require testing, [Enzyme](https://medium.com/airbnb-engineering/enzyme-javascript-testing-utilities-for-react-a417e5e5090f#.tfqch85ic) is useful for testing UI and [plays nicely with Tape](http://airbnb.io/enzyme/docs/guides/tape-ava.html).
6. After integration testing comes end-to-end (e2e) testing, a technique used to test whether the flow of an application right from start to finish is behaving as expected. These tests identify system dependencies and ensure that data integrity is maintained between various system components and systems. Unfortunately, this means we need to [bring Selenium into the picture]( https://medium.com/@TuckerConnelly/good-practices-for-testing-react-apps-3a64154fa3b1#.ouzto5e53). While likely overkill for this project, we could at least set up the infrastructure for later development.
{% marginnote margin3 %} The right proportion of each test kind depends on the particular project, but I would begin by following Google’s 70-20-10 [testing pyramid ](https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html). {% endmarginnote %}

IMAGE

## Creating new features
We’ve got the site working, automated some tests, optimized our page load and components. But what do we do when we want to add more features? What’s the best way of writing tests as we maintain? Test-driven development (TDD) https://medium.com/javascript-scene/tdd-the-rite-way-53c9b46f45e3#.40sc9h1x0






<!-- <span><font size="-1">An early mockup I made of Notist's 'group view'<font size="-1"> -->

<!-- bundle install
bundle exec jekyll serve --baseurl '' -->
